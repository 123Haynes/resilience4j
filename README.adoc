= CircuitBreaker for Java8
:author: Robert Winkler
:version: 0.1.0
:hardbreaks:

This is a CircuitBreaker implementation which works for synchronously and asynchronously calls. The project requires at least JDK 8.
This CircuitBreaker is implemented via a (timed) state machine. The CircuitBreaker does not know anything about the backend's state by itself, but uses only the information provided by calls to {#recordSuccess()} and
{#recordFailure()}.
The state changes from CLOSED to OPEN after a configurable number of attempts have failed consecutively. Then, all access to the backend is blocked for a configurable time interval. After that, the CircuitBreaker is HALF_CLOSED tentatively, to see if the backend is still dead or has become available again.
On success or failure, the state changes back to CLOSED or OPEN, respectively.

== Usage guide

[source,java]
----
// Create a InMemoryCircuitBreakerRegistry
CircuitBreakerRegistry circuitBreakerRegistry = new InMemoryCircuitBreakerRegistry();

// Configure CircuitBreaker
// First parameter configures the maximum number of failures allowed
// Second parameter configures the wait interval [ms] and specifies how long the CircuitBreaker should stay OPEN
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig(1, 1000);

// Get a CircuitBreaker from the CircuitBreakerRegistry
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName", circuitBreakerConfig);

// Prepare test case
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is initially CLOSED
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is still CLOSED, because 1 failure is allowed
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN); // CircuitBreaker is OPEN, because maxFailures > 1

// When
// Wrap a standard Java8 Supplier with a CircuitBreaker
CircuitBreaker.CheckedSupplier<String> checkedSupplier = CircuitBreaker.CheckedSupplier.of(() -> "Hello world", circuitBreaker);
Try<String> result = Try.of(checkedSupplier);

// Then
assertThat(result.isFailure()).isTrue(); // Call fails, because CircuitBreaker is OPEN
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN); // CircuitBreaker is OPEN, because maxFailures > 1
assertThat(result.failed().get()).isInstanceOf(CircuitBreakerOpenException.class); // Exception was CircuitBreakerOpenException
----

== Usage guide with Recovery

If you want to recover from an exception.

[source,java]
----
//Given
CircuitBreakerRegistry circuitBreakerRegistry = new InMemoryCircuitBreakerRegistry();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");

//When
CircuitBreaker.CheckedSupplier<String> checkedSupplier = CircuitBreaker.CheckedSupplier.of(() -> {
    throw new RuntimeException("BAM!");
}, circuitBreaker);
Try<String> result = Try.of(checkedSupplier)
        .recover((throwable) -> "Hello Recovery");

//Then
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("Hello Recovery");
----

== License

Copyright 2015 Robert Winkler

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
