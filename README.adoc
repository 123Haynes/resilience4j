= CircuitBreaker for Java8
:author: Robert Winkler
:version: 0.1.2
:hardbreaks:

image:https://travis-ci.org/RobWin/circuitbreaker-java8.svg?branch=master["Build Status", link="https://travis-ci.org/RobWin/circuitbreaker-java8"] image:https://coveralls.io/repos/RobWin/circuitbreaker-java8/badge.svg["Coverage Status", link="https://coveralls.io/r/RobWin/circuitbreaker-java8"] image:https://api.bintray.com/packages/robwin/maven/circuitbreaker-java8/images/download.svg[link="https://bintray.com/robwin/maven/circuitbreaker-java8/_latestVersion"] image:http://img.shields.io/badge/license-ASF2-blue.svg["Apache License 2", link="http://www.apache.org/licenses/LICENSE-2.0.txt"]

This library is an implementation of the http://martinfowler.com/bliki/CircuitBreaker.html[CircuitBreaker pattern] optimized for Java 8 and functional programming in a multithreaded environment.
The library provides several higher-order functions to decorate any `Supplier / Runnable / Function` or `CheckedSupplier / CheckedRunnable / CheckedFunction` with a Circuit Breaker. In the following I call the higher-order functions `decorators`. The decorators return an enhanced version of your function. Furthermore, the library provides decorators to measure runtime metrics of your functions by using https://dropwizard.github.io/metrics/[Dropwizard Metrics]. You can stack more than one decorator on any given function. That means, you can combine a Metrics decorator with a CircuitBreaker decorator. Any decorated function can be invoked synchronously or asynchronously.
The project should be combined with a functional library for Java 8 like https://github.com/javaslang/javaslang[javaslang]. The project requires at least JDK 8.

The CircuitBreaker is implemented via a finite state machine with three states: `CLOSED`, `OPEN` and `HALF_OPEN`. The CircuitBreaker does not know anything about the backend's state by itself, but uses the information provided by the decorators via `CircuitBreaker::recordSuccess()` and `CircuitBreaker::recordFailure(throwable)`. The decorators are pure functions. The result of a decorator depends solely on the input parameters. See example: 

[source,java]
----
static <T> Supplier<T> decorateSupplier(Supplier<T> supplier, CircuitBreaker circuitBreaker){
    return () -> {
        circuitBreaker.isCallPermitted();
        try {
            T returnValue = supplier.get();
            circuitBreaker.recordSuccess();
            return returnValue;
        } catch (Throwable throwable) {
            circuitBreaker.recordFailure(throwable);
            throw throwable;
        }
    };
}
----

The state of the CircuitBreaker changes from `CLOSED` to `OPEN` if a (configurable) number of call attempts have failed consecutively. Then, all access to the backend is blocked for a (configurable) time interval. `CircuitBreaker::isCallPermitted()` throws a `CircuitBreakerOpenException`, if the CircuitBreaker is `OPEN`.
After the time interval has elapsed, the CircuitBreaker state changes to `HALF_CLOSED` and allows calls to see if the backend is still dead or has become available again. On success or failure, the state changes back to `CLOSED` or `OPEN`, respectively. `CircuitBreaker::recordFailure(throwable)` also checks if the type of exception should increase the number of failure attempts.

== Usage guide

=== Adding circuitbreaker-java8 to your project
The project is published in JCenter and Maven Central.

==== Gradle
[source,groovy]
[subs="attributes"]
----
repositories {
    jcenter()
}

compile "io.github.robwin:circuitbreaker-java8:{version}"
----

=== CircuitBreaker configuration example

[source,java]
----
// Create a InMemoryCircuitBreakerRegistry with global default settings
// (maxFailures = 3, waitInterval = 60[s], ignoredExceptions = empty)
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();

// Create a custom configuration for a CircuitBreaker
// You can configure the maximum number of allowed failures and
// the wait interval [ms] which specifies how long the CircuitBreaker should stay OPEN
// You can add exceptions to the ignore list so that the CircuitBreaker is not triggered
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig.Builder()
    .maxFailures(1).waitInterval(1000).ignoredException(BusinessException.class).build();

// Get a CircuitBreaker from the CircuitBreakerRegistry with custom configuration
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName", circuitBreakerConfig);

// Get a CircuitBreaker from the CircuitBreakerRegistry with global default settings
// (maxFailures = 3, waitInterval = 60[s], ignoredExceptions = empty)
CircuitBreaker circuitBreaker2 = circuitBreakerRegistry.circuitBreaker("otherName");
----

=== Functional programming style

You can decorate any `Supplier / Runnable / Function` or `CheckedSupplier / CheckedRunnable / CheckedFunction` function with `CircuitBreaker.decorateCheckedSupplier()`, `CircuitBreaker.decorateCheckedRunnable()` or `CircuitBreaker.decorateCheckedFunction()`. You can invoke the returned function with `Try.of()` or `Try.run()` from https://github.com/javaslang/javaslang[javaslang].
You can chain further functions with `map`, `flatMap`, `filter`, `recover` or `andThen`. The chained functions are only invoked, if the CircuitBreaker is CLOSED or HALF_CLOSED. `Try.of()` returns a `Success<String>` Monad, if the invocation of the function was successful. If the function itself throws an exception, a `Failure<Throwable>` Monad is returned and `map` is not invoked.

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");

// When
Try.CheckedSupplier<String> decoratedSupplier = CircuitBreaker
        .decorateCheckedSupplier(() -> "This can be any method which returns: 'Hello", circuitBreaker);

// You can chain other functions with `map` and `flatMap`.
// The `Try` Monad returns a `Success<String>`, if the all functions run successfully.
Try<String> result = Try.of(decoratedSupplier)
                .map(value -> value + " world'");

// Then
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("This can be any method which returns: 'Hello world'");
----

=== Example with OPEN CircuitBreaker

In this test case `map` is not invoked, because the CircuitBreaker is OPEN. The call to `Try.of` returns a `Failure<Throwable>` Monad instead.

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig.Builder()
    .maxFailures(1)
    .waitInterval(1000)
    .build();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName", circuitBreakerConfig);

assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is initially CLOSED
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is still CLOSED, because 1 failure is allowed
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN); // CircuitBreaker is OPEN, because maxFailures > 1

// When
Try<String> result = Try.of(CircuitBreaker.decorateCheckedSupplier(() -> "Hello", circuitBreaker))
        .map(value -> value + " world");

// Then
assertThat(result.isFailure()).isTrue(); // Call fails, because CircuitBreaker is OPEN
assertThat(result.failed().get()).isInstanceOf(CircuitBreakerOpenException.class); // Exception is CircuitBreakerOpenException
----

=== Example of Recovery

If you want to recover from any exception, you can chain the method `Try.recover()`. The recovery method is only invoked, if `Try.of()` returns a `Failure<Throwable>` Monad.

[source,java]
----
//Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");

//When
Try.CheckedSupplier<String> checkedSupplier = CircuitBreaker.decorateCheckedSupplier(() -> {
        Thread.sleep(1000);
        throw new RuntimeException("BAM!");
    }, circuitBreaker);
Try<String> result = Try.of(checkedSupplier)
        .recover((throwable) -> "Hello Recovery");

//Then
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("Hello Recovery");
----

=== Example of how to ignore exceptions

The following test cases shows how to add exceptions to the ignore list so that the CircuitBreaker is not triggered.

[source,java]
----
// Given
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig.Builder()
        .maxFailures(1)
        .waitInterval(1000)
        .ignoredException(IOException.class)
        .build();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName", circuitBreakerConfig);

circuitBreaker.recordFailure(new RuntimeException());
// CircuitBreaker is still CLOSED, because 1 failure is allowed
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);

//When the functions throws a subclass of IOException
Try.CheckedRunnable checkedRunnable = CircuitBreaker.decorateCheckedRunnable(() -> {
    throw new SocketTimeoutException("BAM!");
}, circuitBreaker);
Try result = Try.run(checkedRunnable);

//Then the SocketTimeoutException should not trigger the CircuitBreaker, but should be rethrown instead.
assertThat(result.isFailure()).isTrue();
// CircuitBreaker is still CLOSED, because SocketTimeoutException was ignored
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
assertThat(result.failed().get()).isInstanceOf(IOException.class);
----

=== Example with CompletableFuture

You can also invoke a decorated function asynchronously.

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");

// When
Supplier<String> decoratedSupplier = CircuitBreaker
        .decorateSupplier(() -> "This can be any method which returns: 'Hello", circuitBreaker);

CompletableFuture<String> future = CompletableFuture.supplyAsync(decoratedSupplier)
        .thenApply(value -> value + " world'");

//Then
assertThat(future.get()).isEqualTo("This can be any method which returns: 'Hello world'");
----

=== Example with Dropwizard Metrics

You can use https://dropwizard.github.io/metrics/[Dropwizard Metrics] to get execution metrics for your functions. A histogram allows you to measure min, mean, max, standard deviation and quantiles like the median or 95th percentile of the function execution time. A meter measures the rate of the function executions.
The project provides several higher-order functions to decorate any `Supplier / Runnable / Function` or `CheckedSupplier / CheckedRunnable / CheckedFunction` with metrics. 

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");
MetricRegistry metricRegistry = new MetricRegistry();
Timer timer = metricRegistry.timer(name("test"));

// When I create a long running supplier which takes 2 seconds
Try.CheckedSupplier<String> supplier = () -> {
    Thread.sleep(2000);
    return "Hello world";
};

// And measure the time with Metrics
Try.CheckedSupplier<String> timedSupplier = Metrics.timedCheckedSupplier(supplier, timer);

// And decorate it with a CircuitBreaker
Try.CheckedSupplier<String> circuitBreakerAndTimedSupplier = CircuitBreaker
        .decorateCheckedSupplier(timedSupplier, circuitBreaker);

String value = circuitBreakerAndTimedSupplier.get();

// Then the counter of metrics should be one and the
assertThat(timer.getCount()).isEqualTo(1);
// and the mean time should be greater than 2[s]
assertThat(timer.getSnapshot().getMean()).isGreaterThan(2);

assertThat(value).isEqualTo("Hello world");
----

== License

Copyright 2015 Robert Winkler

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
