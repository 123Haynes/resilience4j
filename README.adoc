= CircuitBreaker for Java8
:author: Robert Winkler
:version: 0.1.0
:hardbreaks:

image:https://travis-ci.org/RobWin/circuitbreaker-java8.svg?branch=master["Build Status", link="https://travis-ci.org/RobWin/circuitbreaker-java8"] image:https://coveralls.io/repos/RobWin/circuitbreaker-java8/badge.svg["Coverage Status", link="https://coveralls.io/r/RobWin/circuitbreaker-java8"] image:http://img.shields.io/badge/license-ASF2-blue.svg["Apache License 2", link="http://www.apache.org/licenses/LICENSE-2.0.txt"]

This project is an implementation of the http://martinfowler.com/bliki/CircuitBreaker.html[CircuitBreaker pattern] for Java 8 and functional programming. You can decorate any `Supplier` or `Runnable` function with a Circuit Breaker and use the function synchronously or asynchronously. The project should be combined with a functional library for Java 8 like https://github.com/javaslang/javaslang[javaslang]. The project requires at least JDK 8.

The CircuitBreaker is implemented via a finite state machine and has three states: `CLOSED`, `OPEN` and `HALF_OPEN`. The CircuitBreaker does not know anything about the backend's state by itself, but uses only the information provided by calls to `CircuitBreaker::recordSuccess()` and `CircuitBreaker::recordFailure()`.
The state of the CircuitBreaker changes from `CLOSED` to `OPEN` if a (configurable) number of call attempts have failed consecutively. Then, all access to the backend is blocked for a (configurable) time interval. After that, the CircuitBreaker state changes to `HALF_CLOSED` tentatively, to see if the backend is still dead or has become available again. On success or failure, the state changes back to `CLOSED` or `OPEN`, respectively.

== Usage guide

=== Adding circuitbreaker-java8 to your project
The project is published in JCenter and Maven Central.

==== Maven

[source,xml]
[subs="attributes"]
----
<repositories>
    <repository>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
        <id>central</id>
        <name>bintray</name>
        <url>http://jcenter.bintray.com</url>
    </repository>
</repositories>

<dependency>
    <groupId>io.github.robwin</groupId>
    <artifactId>circuitbreaker-java8</artifactId>
    <version>{version}</version>
</dependency>
----

==== Gradle

[source,groovy]
[subs="attributes"]
----
repositories {
    jcenter()
}

compile "io.github.robwin:circuitbreaker-java8:{version}"
----

=== CircuitBreaker configuration example

[source,java]
----
// Create a InMemoryCircuitBreakerRegistry with global default settings
// (maxFailures = 3, waitInterval = 60[s])
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();

// Configure a CircuitBreaker
// You can configure the maximum number of allowed failures and
// the wait interval [ms] which specifies how long the CircuitBreaker should stay OPEN
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig.Builder()
    .maxFailures(1).waitInterval(1000).build();

// Get a CircuitBreaker from the CircuitBreakerRegistry with custom configuration
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName", circuitBreakerConfig);

// Get a CircuitBreaker from the CircuitBreakerRegistry with global default settings
// (maxFailures = 3, waitInterval = 60[s])
CircuitBreaker circuitBreaker2 = circuitBreakerRegistry.circuitBreaker("otherName");
----

=== Functional programming style

You can decorate any `Supplier` or `Runnable` function with `CircuitBreaker.decorateCheckedSupplier()` or `CircuitBreaker.decorateCheckedRunnable()`. You can invoke the returned function with `Try.of()` or `Try.run()` from https://github.com/javaslang/javaslang[javaslang].
The `map` function is only invoked, if the CircuitBreaker is CLOSED or HALF_CLOSED. `Try.of()` returns a `Success<String>` Monad, if the invocation of the function was successful. If the function itself throws an exception, a `Failure<Throwable>` Monad is returned and the `map` function is not invoked.

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");

// When
Try.CheckedSupplier<String> decoratedSupplier = CircuitBreaker
        .decorateCheckedSupplier(() -> "This can be any method which returns: 'Hello", circuitBreaker);

// You can chain other functions with `map` and `flatMap`.
// The `Try` Monad returns a `Success<String>`, if the all functions run successfully.
Try<String> result = Try.of(decoratedSupplier)
                .map(value -> value + " world'");

// Then
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("This can be any method which returns: 'Hello world'");
----

=== Example with OPEN CircuitBreaker

In this test case `map` is not invoked, because the CircuitBreaker is OPEN. The call to `Try.of` returns a `Failure<Throwable>` Monad and `map` function is not invoked.

[source,java]
----
// Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreakerConfig circuitBreakerConfig = new CircuitBreakerConfig.Builder().maxFailures(1).waitInterval(1000).build();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName", circuitBreakerConfig);

assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is initially CLOSED
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); // CircuitBreaker is still CLOSED, because 1 failure is allowed
circuitBreaker.recordFailure();
assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN); // CircuitBreaker is OPEN, because maxFailures > 1

// When
Try<String> result = Try.of(CircuitBreaker.decorateCheckedSupplier(() -> "Hello", circuitBreaker))
        .map(value -> value + " world");

// Then
assertThat(result.isFailure()).isTrue(); // Call fails, because CircuitBreaker is OPEN
assertThat(result.failed().get()).isInstanceOf(CircuitBreakerOpenException.class); // Exception is CircuitBreakerOpenException
----

=== Example of Recovery

If you want to recover from an exception, you can chain the method `Try.recover()`. The recovery method is only invoked, if `Try.of()` returns a `Failure<Throwable>` Monad.

[source,java]
----
//Given
CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("uniqueName");

//When
 Try.CheckedSupplier<String> checkedSupplier = CircuitBreaker.decorateCheckedSupplier(() -> {
            Thread.sleep(1000);
            throw new RuntimeException("BAM!");
        }, circuitBreaker);
Try<String> result = Try.of(checkedSupplier)
        .recover((throwable) -> "Hello Recovery");

//Then
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("Hello Recovery");
----

=== Example with CompletableFuture

You can also invoke a decorated function asynchronously.

[source,java]
----
// Given
CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("testName");

//When
CircuitBreaker.CheckedSupplier<String> checkedSupplier = CircuitBreaker.CheckedSupplier.of(() -> {
    Thread.sleep(1000);
    throw new RuntimeException("BAM!");
}, circuitBreaker);
CompletableFuture<Try<String>> future = CompletableFuture.supplyAsync(() -> Try.of(checkedSupplier)
        .recover((throwable) -> "Hello Recovery"));

//Then
Try<String> result = future.get();
assertThat(result.isSuccess()).isTrue();
assertThat(result.get()).isEqualTo("Hello Recovery");
----

== License

Copyright 2015 Robert Winkler

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
